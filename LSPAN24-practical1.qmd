---
title: "Handling different data types, quality checking and preparing data files"
author: "Barbara Lazzari, Matilde Passamonti, Paolo Cozzi, Stefano Capomaccio"
format: 
  revealjs:
    chalkboard: true
    footer: "Livestock pangenomes 2024 - Practical 1 - 2024/07/22"
---

## Practical introduction

To follow this and other practicals, a working *NIX environment is required. 
We suggest to use a Linux distribution, MacOS or Windows with
[WSL2](https://learn.microsoft.com/en-us/windows/wsl/about).

If you don't have a working environment, you can use [GitPod](https://www.gitpod.io/),
a cloud-based IDE that allows you to work on your projects from anywhere. We suggest:

*   A [GitHub](https://github.com/) account to manage authentication. 
*   A [Linkedin](https://www.linkedin.com/) account to get access to 50 hours of 
    free usage per month.

::: notes
Introducing GitPod: is not mandatory for the practicals, but it is a good way to
work on the practicals without the need to install anything on your local machine.
This can be useful if you have a slow internet connection, or if you are not allowed
to install software on your machine.
In the GitPod environment, we manage the software installation and the environment
but you can install additional software if needed.
:::

## Introduction to GitPod

Go to <https://www.gitpod.io/> and select the **Try for free** button

![](img/gitpod_home.png){fig-align="center" .r-stretch}

## Link your GitHub account to GitPod (recommended)

Add your *linkedin* account to get 50 hours of free usage per month

![](img/gitpod_login.png){fig-align="center" .r-stretch}

::: notes
Select your preferred editor (VS code is recommened), 
theme, and profile details, click continue and your 
account will be created and ready to use.
:::

## GitPod pricing plans

![](img/gitpod_pricing.png){fig-align="center" .r-stretch}

::: notes
GitPod has a free tier that allows you to use the service for 50 hours per month.
You don't need to provide any payment details to follow these practicals.
:::

See your resource usage at <https://gitpod.io/billing>

## GitPod Workspaces

<https://gitpod.io/workspaces>

![](img/gitpod_workspace.png){fig-align="center" .r-stretch}

::: notes
A workspace is a cloud-based development environment that allows you to work on your
projects from anywhere. You can create a workspace from a GitHub repository, or you
can create an empty workspace and clone a repository from the terminal.
Here you can see a list of your active workspaces, the status, the time of the last
activity, and the instance size (if any).
:::

## Create a workspace

![](img/gitpod_create_workspace.png){fig-align="center" .r-stretch}

Click [here](https://gitpod.io/#https://github.com/bunop/LSPAN24-practical1) 
to create a new workspace for this project!

::: notes
when creating a workspace, you can select a repository from GitHub, the default
editor and the instance size. If you use the *Large* instance, you will consume
your free credits **faster**
:::

## VS Code in GitPod

![](img/gitpod_vscode.png){fig-align="center" .r-stretch}

Take a look at VS Code tutorial, for example [this one](https://www.youtube.com/watch?v=B-s71n0dHUk)

::: notes
Please note the 4 different sections of the VS Code interface: at the bottom is 
the terminal, on the left is the file explorer, in the middle is the editor, and
on the left-up corner is the hamburger menu that allows you to access the settings
and the extensions.
:::

## Turning off Workspaces

![](img/gitpod_stopworkspace.1.png){.absolute top=100 left=0 width="auto" height="500"}
![](img/gitpod_stopworkspace.2.png){.absolute bottom=0 right=0 width="700" height="auto"}

::: notes
Remember to stop your workspace when you are not using it, to save your free credits.
You can stop your current workspace by clicking on the hamburger menu fromn VScode 
or from the hamburger menu in the workspace list
:::

## GitPod CLI

You can install the [GitPod CLI ](https://www.gitpod.io/docs/references/gitpod-cli)
to manage your workspaces from the terminal

```{.bash}
# login to GitPod
gitpod login

# list available workspaces
gitpod workspace list

# start a workspace
gitpod workspace start <workspace ID>

# open a linux terminal into workspace
gitpod workspace ssh <workspace ID>
```


## Workspaces lifecycle

::: incremental
*   Workspaces are automatically stopped after 30 minutes of inactivity or after
    8 hours (using a free plan)
    +   Only files and directories inside `/workspace` directory are preserved.
*   Workspaces are deleted after **14 days**
    +   remember to save your work
*   Please see 
    [Workspace Lifecycle](https://www.gitpod.io/docs/configure/workspaces/workspace-lifecycle)
    for more information
:::

## Using the Command Line

For scientific computing, a command-line interface (CLI) is often essential.
This means typing out commands instead of using a mouse.

::: incremental
*   Numerous tools are exclusively available as command-line utilities.
*   Once familiar, the CLI can be faster and more precise.
*   Tasks can be easily automated through scripting.
*   High-performance computing (HPC) environments often rely solely on CLI access.
:::

## Filesystem Hierarchy {.smaller}

::: columns

::: {.column width="50%"}
The filesystem is organized in a tree-like structure, with the root directory
`/` at the top.

::: incremental
*   `/` is the root directory.
*   `/home` contains user directories.
*   `/usr` contains user programs.
*   `/bin` contains essential binaries.
*   `/etc` contains system configuration files.
*   `/var` contains variable data.
*   `/tmp` contains temporary files.
*   `/workspace` specific to GitPod.
:::

:::

::: {.column width="50%" .absolute top=200 right=0}
![Dhanusha Dhananjaya, [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0), via Wikimedia Commons](https://upload.wikimedia.org/wikipedia/commons/4/4b/Linux_file_system_foto_no_exif_%281%29.jpg){fig-width=100% fig-cap-location=bottom}
:::

:::

## Absolute vs. Relative Paths {.smaller}

::: incremental
*   **Absolute paths** start from the root directory `/`.
    +   e.g., `/`, `/home/user/file.txt`, `/home/user/data/`.
*   **Relative paths** start from the current directory.
    +   e.g., `file.txt`, `user/data/file.txt`.
    +   `.` refers to the current directory (e.g., `./file.txt`)
    +   `..` refers to the parent directory (e.g., `../file.txt`).
        Can be chained multiple times (e.g., `../../file.txt`)
:::

. . .

Consider this example:

```{.txt}
dir1/
├── dir2
│   └── file2
└── file1
```

`../file1` is relative to `file2` current position (`dir2`)

`../../dir1` is relative to `file2` current position (`dir2`)

## Navigate the Filesystem {.smaller}

Here are some basic commands to navigate the filesystem: each command can
accept a **path** and **additional option(s)** as an argument. The general
rule is:

`command [option(s)] [path]`

::: incremental
*   `pwd`: Print current working directory (absolute path).
*   `ls`: List files and directories.
*   `cd`: Change directory.
*   `mkdir`: Make directory.
*   `rmdir`: Remove directory (safer).
*   `touch`: Create an empty file - set the timestamp of a file to the current time.
*   `rm`: Remove files.
*   `mv`: Move or rename files.
*   `cp`: Copy files.
:::

## `ls` useful options {.smaller}

`ls` shows files and directories in the current directory. You can provide a
**path** to list files in a different directory. Here are some useful options:

*   `ls -l`: List files with details.
*   `ls -a`: List all files, including hidden ones.
*   `ls -lh`: List files with human-readable sizes.
*   `ls -t`: List files by modification time.
*   `ls -S`: List files by size.
*   `ls -R`: List files recursively.
*   `ls -r`: List files in reverse order.
*   `ls -1`: List files in a single column.

You can combine options, e.g., `ls -lhSr /home/user/data` to list files 
in `/home/user/data` folder with *human-readable sizes*
ordered by *size* in *ascending* order (bigger files on *bottom*).

## Useful options for other commands {.smaller}

*   Without a path:
    +   `cd`: (without any arguments) change to **your home** directory
    +   `cd -`: change to the previous directory
*   With a path (*relative or absolute*)
    +   `mkdir -p`: create a directory with its parents if they do not exist
    +   `rm -r`: remove directories and their contents recursively (**use with caution**)
    +   `rm -i`: prompt before removing files
    +   `mv -i`: prompt before overwriting files
    +   `cp -r`: copy directories and their contents recursively
    +   `cp -i`: prompt before overwriting files

. . .

Can you guess the difference between `rm -r` and `rmdir`?

## Navigate the Filesystem (exercise) {.smaller}

1.  Open a terminal (if not yet open)
2.  Print the current working directory
3.  List the files and directories
4.  Change to your *home* directory
5.  Create a new directory called `mydir`
6.  Change to the `mydir` directory
7.  Create a new file called `myfile.txt`
8.  List the files and directories
9.  Move `myfile.txt` to the *home* directory
10.  Remove the `mydir` directory
11.  List the files and directories

## Wildcards {.smaller}

Wildcards are characters that help match file names based on patterns. Ex:

::: incremental
-   `*`: Matches any number of characters (`file*` matches `file1`, `file2`, `fileverylong` etc.)
-   `?`: Matches a single character (`file?` matches `file1`, `file2`, but not `fileverylong`)
-   `[ ]`: Matches any character within the brackets (`file[12]` matches `file1`, `file2`, but
    not `file3` or `fileverylong`. `file[1-9]` to match file with any digit)
-   `{ }`: Matches any of the comma-separated word (`file{1,2,verylong}` 
    matches `file1`, `file2` and `fileverylong`)
:::

## Special characters

Some characters have special meanings in the shell:

::: incremental
*   `~`: expands to the home directory (`cd ~`, `cd ~/data`)
*   `$`: expands to the value of the variable (`echo $HOME`, `echo $PWD`)
*   `;`: separates commands in one line (execute commands with this order e.g. 
    `cd /tmp; ls` first change to `/tmp` then list files)
*   `\`: escapes the next character (`ls file\ with\ spaces.txt`)
:::



## Introduction to virtual environment

Something on virtual environments in general. Then introduce conda and mamba.

-   Python: virtualenv, pyenv, poetry
-   R: packrat, renv
-   Perl: perlbrew, local::lib
-   Ruby: rvm

::: notes
something on reproducibility and the need for virtual environments.
:::

## Introduction to Conda

-   [Conda](https://docs.anaconda.com/anaconda/install/): A package manager and environment management system for installing and managing software packages and dependencies, particularly for Python and R.

::: incremental
-   [Miniconda](https://docs.anaconda.com/miniconda/): A minimal installer for Conda that includes Conda, Python, and other essential packages.
-   [Mamba](https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html): A faster, drop-in replacement for Conda. You can swap almost all commands between `conda` & `mamba`
:::

::: notes
conda to install dependencies and softwares
Conda: has navigators, softwares for installing packages using GUI and editors like spyder, jupyter notebook, etc. Suggested on local machines. Miniconda: is a lightweight version of Conda, suggested on servers or where the GUI is not available. Mamba: implemented the package resolvers in C++ and is faster than Conda. However conda has introduced a new package resolver last year. It has some additional features like `repoquery`.
:::

## Create an environment (from scratch)

We use `conda` command to manage environments with `conda` / `miniconda`:

-   replace with `mamba` if you have `mamba` installed.
-   `--name`: required to specify the name of the environment.
-   specifying versions helps the package resolver

``` {.bash code-line-numbers="1-2|4-5|7-8"}
# create an empty environment
conda create --name empty

# create an environment with some software
conda create --name python python ipython

# create an environment with a specific software version
conda create --name python3.10 python=3.10 ipython=8.25
```

## Create an environment (from file)

We can also create an environment from a file. Note the `env` before the `create` command:

-   `--file`: specify the file containing the environment specifications
-   `--name`: override the name of the environment in the file

``` {.bash code-line-numbers="1-2"}
# create an environment from a file
conda env create --file environment.yml
```

::: notes
without the `--file` option, the current `environment.yml` file will be used.
:::

## List and activate environments

-   `conda env list`: list all environments
-   `conda activate <env_name>`: activate an environment

Normally the prompt will change to show the active environment. Default installation
have the `base` environment active at login

```bash
(base) paolo@bullseye-laptop:~$ conda activate ognigenoma
(ognigenoma) paolo@bullseye-laptop:~$
```

## Channels and repositories

-   `defaults`: the default channel for conda packages
-   `bioconda`: a channel for bioinformatics software
-   `R`: a channel for R packages
-   `conda-forge`: a community-driven collection of conda packages

``` {.bash code-line-numbers="1-2|4-6"}
# add a channel to the list of channels
conda config --add channels conda-forge

# add a channel to the list of channels
conda config --add channels bioconda
```

## Search for packages

## Install packages

*   `conda install`: install packages in the active environment
    +   `--name`: specify the environment to install the package
    +   `--file`: specify a file with the list of packages to install

``` {.bash code-line-numbers="1-2|4-5|7-9"}
# install a package in the active environment
conda install pandas

# install a package in a specific environment
conda install --name python3.10 pandas

# install packages from a file in the active environment 
# (python format)
conda install --file requirements.txt
```

## Exporting an environment

-   `conda env export`: export the environment to a file
-   `--name`: specify the environment to export
-   `--file`: specify the file to export the environment to
-   `--no-builds`: exclude the build string from the exported file

``` {.bash code-line-numbers="1-2|4-5|7-8"}
# export the active environment to a file (using STDOUT)
conda env export > environment.yml

# export a specific environment to a file
conda env export --name python3.10 > environment.yml

# export a specific environment to a specific file
conda env export --name python3.10 --file environment.yml
```

::: notes
does people know STDOUT/STDERR/STDIN?
:::

## Some tips

::: incremental
-   `conda list`: list all packages installed in the active environment
-   Install packages with versions: `conda install pandas=1.3.3`
-   Create environments by scope: don't pull all packages in the same environment
-   Limit the `conda-forge` channel usage if possible
-   `conda list --revision`: list all revisions of the environment
:::
